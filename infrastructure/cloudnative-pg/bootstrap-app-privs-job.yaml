---
apiVersion: batch/v1
kind: Job
metadata:
  name: bootstrap-app-privs
  namespace: postgres
  labels:
    environment: env
spec:
  ttlSecondsAfterFinished: 600
  template:
    spec:
      restartPolicy: OnFailure
      initContainers:
        - name: wait-for-postgres
          image: postgres:15
          env:
            - name: ENVIRONMENT
              valueFrom:
                fieldRef:
                  fieldPath: metadata.labels['environment']
            - name: PGPORT
              value: "5432"
          command:
            - sh
            - -ceu
            - |
              set -o pipefail

              # Default ENVIRONMENT if label missing (e.g. manual run)
              ENVIRONMENT="${ENVIRONMENT:-stable}"
              PGHOST="${PGHOST:-pg-core-rw.postgres.svc.cluster.local}"
              PGPORT="${PGPORT:-5432}"

              echo "Waiting for Postgres at $PGHOST:$PGPORT ..."
              until pg_isready -h "$PGHOST" -p "$PGPORT"; do
                echo "Postgres not ready yet..."
                sleep 3
              done
              echo "Postgres is ready!"
      containers:
        - name: psql
          image: ghcr.io/cloudnative-pg/postgresql:16
          command: ["/bin/bash", "-ceu", "--"]
          args:
            - |
              set -o pipefail

              echo "[bootstrap] Starting app privilege bootstrap"

              # --- read superuser creds from pg-core-superuser secret ---
              PGUSER="$(cat /secrets/pg-core-superuser/username)"
              PGPASSWORD="$(cat /secrets/pg-core-superuser/password)"
              export PGUSER PGPASSWORD

              # --- derive PGHOST from environment label if not provided ---
              ENVIRONMENT="${ENVIRONMENT:-stable}"
              PGHOST="${PGHOST:-pg-core-rw.postgres.svc.cluster.local}"
              PGPORT="${PGPORT:-5432}"
              export PGHOST PGPORT

              OWNER_ROLE="${DB_ROOT_OWNER:-db_root_owner}"

              echo "[bootstrap] Using OWNER_ROLE=${OWNER_ROLE}, ENVIRONMENT=${ENVIRONMENT}, PGHOST=${PGHOST}, PGPORT=${PGPORT}"

              # --- loop: check DB exists, then apply default-privs.sql ---
              while read -r DB_NAME APP_ROLE; do
                # Skip empty/comment lines
                if [[ -z "${DB_NAME:-}" ]] || [[ "${DB_NAME}" =~ ^# ]]; then
                  continue
                fi

                echo "[bootstrap] Checking existence of DB '${DB_NAME}'"

                if psql -tc "SELECT 1 FROM pg_database WHERE datname = '${DB_NAME}'" | grep -q 1; then
                  echo "[bootstrap] Database '${DB_NAME}' exists; applying privilege bootstrap (APP_ROLE='${APP_ROLE}')"

                  psql \
                    "dbname=${DB_NAME}" \
                    -v ON_ERROR_STOP=1 \
                    -v DB_NAME="${DB_NAME}" \
                    -v OWNER_ROLE="${OWNER_ROLE}" \
                    -v APP_ROLE="${APP_ROLE}" \
                    -f /sql/default-privs.sql
                else
                  echo "[bootstrap] WARNING: database '${DB_NAME}' does not exist yet; skipping"
                fi
              done < /config/apps

              echo "[bootstrap] Completed app privilege bootstrap"
          env:
            - name: DB_ROOT_OWNER
              value: db_root_owner
            - name: ENVIRONMENT
              valueFrom:
                fieldRef:
                  fieldPath: metadata.labels['environment']
          volumeMounts:
            - name: app-list
              mountPath: /config
            - name: sql
              mountPath: /sql
            - name: pg-core-superuser
              mountPath: /secrets/pg-core-superuser

      volumes:
        - name: app-list
          configMap:
            name: app-list
            items:
              - key: apps
                path: apps
        - name: sql
          configMap:
            name: default-privs-sql
            items:
              - key: default-privs.sql
                path: default-privs.sql
        - name: pg-core-superuser
          secret:
            secretName: pg-core-superuser
